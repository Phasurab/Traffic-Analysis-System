import sqlite3
import json
from datetime import datetime
from pathlib import Path

# Connect to the SQLite database
# Using a relative path from this file to locate the DB inside the "outputs" directory
DB_PATH = Path(__file__).resolve().parent / "outputs" / "traffic.db"


def get_db_connection():
    """Establish and return a connection to the SQLite database."""
    # Ensure the outputs directory exists before creating the DB!
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row  # This enables column access by name: row['column_name']
    return conn


def initialize_db():
    """Create the necessary database tables if they do not exist."""
    conn = get_db_connection()
    cursor = conn.cursor()

    # 1. Tasks Table: Metadata about the uploaded video run
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS tasks (
            task_id TEXT PRIMARY KEY,
            filename TEXT NOT NULL,
            model TEXT NOT NULL,
            status TEXT NOT NULL,
            error_message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # 2. Zones Table: Stores the user-drawn polygons and lines configured for the task
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS zones (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            task_id TEXT NOT NULL,
            name TEXT NOT NULL,
            geometry_type TEXT NOT NULL,
            coordinates TEXT NOT NULL, -- JSON string array of coordinates
            FOREIGN KEY(task_id) REFERENCES tasks(task_id) ON DELETE CASCADE
        )
    ''')

    # 3. Results Table: Stores the actual counts generated by the AI tracking pipeline
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            task_id TEXT NOT NULL,
            timestamp TIMESTAMP NOT NULL,
            geometry_name TEXT NOT NULL, -- Name of the Area/Trajectory
            geometry_type TEXT NOT NULL, -- "Area" or "Trajectory"
            vehicle_class TEXT NOT NULL,
            count INTEGER NOT NULL,
            FOREIGN KEY(task_id) REFERENCES tasks(task_id) ON DELETE CASCADE
        )
    ''')
    
    conn.commit()
    conn.close()

# Initialize tables immediately upon import
initialize_db()

# --- HELPER FUNCTIONS ---

def create_task(task_id: str, filename: str, model: str):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO tasks (task_id, filename, model, status) VALUES (?, ?, ?, ?)",
        (task_id, filename, model, "processing")
    )
    conn.commit()
    conn.close()

def update_task_status(task_id: str, status: str, error_message: str = None):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "UPDATE tasks SET status = ?, error_message = ? WHERE task_id = ?",
        (status, error_message, task_id)
    )
    conn.commit()
    conn.close()

def save_task_zones(task_id: str, spec_data: dict):
    conn = get_db_connection()
    cursor = conn.cursor()
    
    features = spec_data.get("zones", {}).get("features", [])
    
    for feature in features:
        name = feature.get("properties", {}).get("name", "Unknown")
        geom_type = feature.get("geometry", {}).get("type", "Unknown")
        coords = feature.get("geometry", {}).get("coordinates", [])
        
        cursor.execute(
            "INSERT INTO zones (task_id, name, geometry_type, coordinates) VALUES (?, ?, ?, ?)",
            (task_id, name, geom_type, json.dumps(coords))
        )
        
    conn.commit()
    conn.close()

def save_tracking_results(task_id: str, final_output: dict):
    """
    Saves the extracted tracking counts from the pipeline into the database.
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Insert Area counts
    for area_name, counts_list in final_output.get("areas", {}).items():
        for count_dict in counts_list:
            for v_class, cnt in count_dict.items():
                cursor.execute(
                    "INSERT INTO results (task_id, timestamp, geometry_name, geometry_type, vehicle_class, count) VALUES (?, ?, ?, ?, ?, ?)",
                    (task_id, current_time, area_name, "Area", v_class, cnt)
                )
                
    # Insert Trajectory (Path A to Path B) counts
    for path_name, counts_list in final_output.get("paths", {}).items():
        for count_dict in counts_list:
            for v_class, cnt in count_dict.items():
                cursor.execute(
                    "INSERT INTO results (task_id, timestamp, geometry_name, geometry_type, vehicle_class, count) VALUES (?, ?, ?, ?, ?, ?)",
                    (task_id, current_time, path_name, "Trajectory", v_class, cnt)
                )

    conn.commit()
    conn.close()
